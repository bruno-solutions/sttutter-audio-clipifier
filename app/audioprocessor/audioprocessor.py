"""
The main audio processing module
"""
import json
from pathlib import Path

import pydub
from pydub.utils import register_pydub_effect

import downloader
from configuration import EXTERNAL_DOWNLOADER, DOWNLOADED_AUDIO_FILE_NAME, EXPORT_FILE_TYPE, DURATION, THRESHOLD, CLIP_LIMIT, DEFAULT_SAMPLE_RATE, METADATA_FILE_NAME
from normalizer import Normalizer
from slicer import Slicer
from tagger import Tagger


class AudioProcessor:
    """
    The class that orchestrates the audio processing methods
    """

    def __init__(self, url, slicers, downloaded_audio_file_name=DOWNLOADED_AUDIO_FILE_NAME, sample_rate=DEFAULT_SAMPLE_RATE, external_downloader=EXTERNAL_DOWNLOADER, logger=None):
        self.url = url

        self.downloaded_audio_file_name = downloaded_audio_file_name
        self.sample_rate = sample_rate
        self.slicer_names = []

        self.external_downloader = external_downloader
        self.normalizer = Normalizer()
        self.logger = logger
        self.recording = None
        self.tagger = None

        self.clips = list()

        def register(remaining_slicers):
            """
            Registers custom slicer methods from this Slicer class in pydub's effects list
            """
            if isinstance(remaining_slicers, dict):
                for named_method in remaining_slicers.items():
                    register(named_method)
                return

            if isinstance(remaining_slicers, tuple):
                name, method = remaining_slicers

                # https://github.com/jiaaro/pydub/blob/master/pydub/utils.py#LC108
                # https://github.com/jiaaro/pydub/blob/master/pydub/effects.py

                @register_pydub_effect(name)
                def registered_slicer(rate, duration, threshold, samples, count, *args, **kwargs):
                    slicer = Slicer(rate, duration, threshold, samples, count, self.tagger)  # instantiate a Slicer object
                    getattr(slicer, method)(*args, **kwargs)  # call the registered slicer method on the Slicer object
                    return slicer.slice().clips  # return the clips generated by the registered slicer method

                self.slicer_names.append(name)
                return

            raise TypeError

        register(slicers)

    def download(self):
        """
        Downloads a file and converts it into a pydub AudioSegmant object
        """
        downloader.download(self.url, logger=self.logger, external_downloader=self.external_downloader)
        self.recording = pydub.AudioSegment.from_file(self.downloaded_audio_file_name).set_frame_rate(self.sample_rate)
        return self

    def metadata(self):
        with open(METADATA_FILE_NAME) as json_file:
            self.tagger = Tagger(json.load(json_file))
            self.tagger.write_tags(self.downloaded_audio_file_name)
        return self

    def normalize(self):
        """
        Normalize recording volume
        """
        self.recording = self.normalizer.normalize(self.recording)
        return self

    def slice(self, duration=DURATION, threshold=THRESHOLD, clip_limit=CLIP_LIMIT):
        """
        Loads and executes the slicer module
        """
        if 0 == len(self.slicer_names):
            raise RuntimeError("No slicers are configured")

        for slicer_name in self.slicer_names:
            self.clips.extend(getattr(pydub.AudioSegment, slicer_name)(self.sample_rate, duration, threshold, self.recording, clip_limit))
        # slicer = getattr(pydub.AudioSegment, self.slicer_names[0])  # adjust this to cycle through all slicers
        #
        # self.clips = slicer(self.sample_rate, duration, threshold, self.recording, clip_limit)
        return self

    def fade(self, fadein_duration=500, fadeout_duration=500):
        """
        Append fade-in and fade-out
        """
        for index, clip in enumerate(self.clips):
            self.clips[index] = clip.fade_in(fadein_duration).fade_out(fadeout_duration)
        return self

    def export(self, directory):
        """
        Export the audio clips
        """
        for index, clip in enumerate(self.clips):
            Path(directory).mkdir(parents=True, exist_ok=True)
            filename = f"{directory}\\{index}.{EXPORT_FILE_TYPE}"
            clip.export(filename, format=EXPORT_FILE_TYPE).close()
            self.tagger.write_tags(filename)
        return self
